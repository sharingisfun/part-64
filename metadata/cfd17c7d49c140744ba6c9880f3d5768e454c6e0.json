{"title":"reset_glitch_hack_v1.0","uid":6638301,"size":2691803,"categoryP":"games","categoryS":"xbox360","magnet":"?xt=urn:btih:cfd17c7d49c140744ba6c9880f3d5768e454c6e0&amp;dn=reset_glitch_hack_v1.0&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&amp;tr=udp%3A%2F%2Fopen.demonii.com%3A1337&amp;tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&amp;tr=udp%3A%2F%2Fexodus.desync.com%3A6969","seeders":0,"leechers":1,"uploader":"fArGo1911","files":2,"time":1314646593,"description":"The Xbox 360 reset glitch hack - New Homebrew Hack!\n###################################################\n\n&gt;&gt; GliGli released a new hack to boot the Xbox360 into XeLL and thus run homebrew software on your console. It's is \n\ncompatible with ALL dashboard version and ALL Slim and Fat (expect Xenon, Falcon support will follow later) models and is \n\nunpatchable via software updates by Microsoft.\n\nFrom the readme/nfo:\n[QUOTE]\nIntroduction / some important facts\n===================================\n\ntmbinc said it himself, software based approaches of running unsigned code on the 360 mostly don't work, it was designed to \n\nbe secure from a software point of view.\n\nThe processor starts running code from ROM (1bl) , which then starts loading a RSA signed and RC4 crypted piece of code \n\nfrom NAND (CB).\n\nCB then initialises the processor security engine, its task will be to do real time encryption and hash check of physical \n\nDRAM memory. From what we found, it's using AES128 for crypto and strong (Toeplitz ?) hashing. The crypto is different each \n\nboot because it is seeded at least from:\n- A hash of the entire fuseset.\n- The timebase counter value.\n- A truly random value that comes from the hardware random number generator the processor embeds. on fats, that RNG could \n\nbe electronically deactivated, but there's a check for &quot;apparent randomness&quot; (merely a count of 1 bits) in CB, it just \n\nwaits for a seemingly proper random number.\n\nCB can then run some kind of simple bytecode based software engine whose task will mainly be to initialise DRAM, CB can \n\nthen load the next bootloader (CD) from NAND into it, and run it.\n\nBasically, CD will load a base kernel from NAND, patch it and run it.\n\nThat kernel contains a small privileged piece of code (hypervisor), when the console runs, this is the only code that would \n\nhave enough rights to run unsigned code.\nIn kernel versions 4532/4548, a critical flaw in it appeared, and all known 360 hacks needed to run one of those kernels \n\nand exploit that flaw to run unsigned code.\nOn current 360s, CD contains a hash of those 2 kernels and will stop the boot process if you try to load them.\nThe hypervisor is a relatively small piece of code to check for flaws and apparently no newer ones has any flaws that could \n\nallow running unsigned code.\n\nOn the other hand, tmbinc said the 360 wasn't designed to withstand certain hardware attacks such as the timing attack and \n\n&quot;glitching&quot;.\n\nGlitching here is basically the process of triggering processor bugs by electronical means.\n\nThis is the way we used to be able to run unsigned code.\n\nThe reset glitch in a few words\n===============================\n\nWe found that by sending a tiny reset pulse to the processor while it is slowed down does not reset it but instead changes \n\nthe way the code runs, it seems it's very efficient at making bootloaders memcmp functions always return &quot;no differences&quot;. \n\nmemcmp is often used to check the next bootloader SHA hash against a stored one, allowing it to run if they are the same. \n\nSo we can put a bootloader that would fail hash check in NAND, glitch the previous one and that bootloader will run, \n\nallowing almost any code to run.\n\nDetails for the fat hack\n========================\n\nOn fats, the bootloader we glitch is CB, so we can run the CD we want.\n\ncjak found that by asserting the CPU_PLL_BYPASS signal, the CPU clock is slowed down a lot, there's a test point on the \n\nmotherboard that's a fraction of CPU speed, it's 200Mhz when the dash runs, 66.6Mhz when the console boots, and 520Khz when \n\nthat signal is asserted.\n\nSo it goes like that:\n- We assert CPU_PLL_BYPASS around POST code 36 (hex).\n- We wait for POST 39 start (POST 39 is the memcmp between stored hash and image hash), and start a counter.\n- When that counter has reached a precise value (it's often around 62% of entire POST 39 length), we send a 100ns pulse on \n\nCPU_RESET.\n- We wait some time and then we deassert CPU_PLL_BYPASS.\n- The cpu speed goes back to normal, and with a bit of luck, instead of getting POST error AD, the boot process continues \n\nand CB runs our custom CD.\n\nThe NAND contains a zero-paired CB, our payload in a custom CD, and a modified SMC image.\nA glitch being unreliable by nature, we use a modified SMC image that reboots infinitely (ie stock images reboot 5 times \n\nand then go RROD) until the console has booted properly.\nIn most cases, the glitch succeeds in less than 30 seconds from power on that way.\n\nDetails for the slim hack\n=========================\n\nThe bootloader we glitch is CB_A, so we can run the CB_B we want.\n\nOn slims, we weren't able to find a motherboard track for CPU_PLL_BYPASS.\nOur first idea was to remove the 27Mhz master 360 crystal and generate our own clock instead but it was a difficult \n\nmodification and it didn't yield good results.\nWe then looked for other ways to slow the CPU clock down and found that the HANA chip had configurable PLL registers for \n\nthe 100Mhz clock that feeds CPU and GPU differential pairs.\nApparently those registers are written by the SMC through an I2C bus.\nI2C bus can be freely accessed, it's even available on a header (J2C3).\nSo the HANA chip will now become our weapon of choice to slow the CPU down (sorry tmbinc, you can't always be right, it \n\nisn't boring and it does sit on an interesting bus ;)\n\nSo it goes like that:\n- We send an i2c command to the HANA to slow down the CPU at POST code D8 .\n- We wait for POST DA start (POST DA is the memcmp between stored hash and image hash), and start a counter.\n- When that counter has reached a precise value, we send a 20ns pulse on CPU_RESET.\n- We wait some time and then we send an i2c command to the HANA to restore regular CPU clock.\n- The cpu speed goes back to normal, and with a bit of luck, instead of getting POST error F2, the boot process continues \n\nand CB_A runs our custom CB_B.\n\nWhen CB_B starts, DRAM isn't initialised so we chose to only apply a few patches to it so that it can run any CD, the \n\npatches are:\n- Always activate zero-paired mode, so that we can use a modified SMC image.\n- Don't decrypt CD, instead expect a plaintext CD in NAND.\n- Don't stop the boot process if CD hash isn't good.\n\nCB_B is RC4 crypted, the key comes from the CPU key, so how do we patch CB_B without knowing the CPU key?\nRC4 is basically:\ncrypted = plaintext xor pseudo-random-keystream\nSo if we know plaintext and crypted, we can get the keystream, and with the keystream, we can encrypt our own code. It goes \n\nlike that:\nguessed-pseudo-random-keystream = crypted xor plaintext\nnew-crypted = guessed-pseudo-random-keystream xor plaintext-patch\nYou could think there's a chicken and egg problem, how did we get plaintext in the first place?\nEasy: we had plaintext CBs from fat consoles, and we thought the first few bytes of code would be the same as the new CB_B, \n\nso we could encrypt a tiny piece of code to dump the CPU key and decrypt CB_B!\n\nThe NAND contains CB_A, a patched CB_B, our payload in a custom plaintext CD, and a modified SMC image.\nThe SMC image is modified to have infinite reboot, and to prevent it from periodically sending I2C commands while we send \n\nours.\n\nNow, maybe you haven't realised yet, but CB_A contains no checks on revocation fuses, so it's an unpatchable hack !\n\nCaveats\n=======\n\nNothing is ever perfect, so there are a few caveats to that hack:\n- Even in the glitch we found is pretty reliable (25% success rate per try on average), it can take up to a few minutes to \n\nboot to unsigned code.\n- That success rate seems to depend on something like the hash of the modified bootloader we want to run (CD for fats and \n\nCB_B for slims).\n- It requires precise and fast hardware to be able to send the reset pulse.\n\nOur current implementation\n==========================\n\nWe used a Xilinx CoolRunner II CPLD (xc2c64a) board, because it's fast, precise, updatable, cheap and can work with 2 \n\ndifferent voltage levels at the same time.\nWe use the 48Mhz standby clock from the 360 for the glitch counter. For the slim hack, the counter even runs at 96Mhz \n\n(incremented on rising and falling edges of clock)\nThe cpld code is written in VHDL.\nWe need it to be aware of the current POST code, our first implementations used the whole 8 bits POST port for this, but we \n\nare now able to detect the changes of only 1 POST bit, making wiring easier.\n\nConclusion\n==========\n\nWe tried not to include any MS copyrighted code in the released hack tools.\nThe purpose of this hack is to run Xell and other free software, I (GliGli) did NOT do it to promote piracy or anything \n\nrelated, I just want to be able to do whatever I want with the hardware I bought, including running my own native code on \n\nit.\n\nCredits\n=======\n\nGliGli, Tiros: Reverse engineering and hack development.\ncOz: Reverse engineering, beta testing.\nRazkar, tuxuser: beta testing.\ncjak, Redline99, SeventhSon, tmbinc, anyone I forgot... : Prior reverse engineering and/or hacking work on the 360.\n[/QUOTE]\n\nOfficial Site: github.com/gligli","torrent":{"xt":"urn:btih:cfd17c7d49c140744ba6c9880f3d5768e454c6e0","amp;dn":"reset_glitch_hack_v1.0","amp;tr":["udp%3A%2F%2Ftracker.openbittorrent.com%3A80","udp%3A%2F%2Fopen.demonii.com%3A1337","udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969","udp%3A%2F%2Fexodus.desync.com%3A6969"],"infoHash":"cfd17c7d49c140744ba6c9880f3d5768e454c6e0","infoHashBuffer":{"type":"Buffer","data":[207,209,124,125,73,193,64,116,75,166,201,136,15,61,87,104,228,84,198,224]},"announce":[],"urlList":[]}}